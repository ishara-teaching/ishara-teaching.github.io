---
layout: base
title: Teaching Philosophy
---

Teaching Philosophy
-------------------

Computer Science treads a fine line between playfulness and discipline. Programming languages have the power to change lives using nothing more than text on a screen and electrons across wires. Yet, when built carelessly, the same programs can put the privacy and productivity of real people at risk. As an instructor, especially for beginning programmers or non-majors, I prioritize the development of intuition through play and just-in-time learning, and the refinement of discipline through structured instruction and reflection.

As programming environments afford play and exploration, I like to take advantage of the interactivity of these environments to foster the development of intuition. Programming environments are an interesting manipulative as they provide several levels of real-time feedback automatically, without the need for an instructor. When a student writes code to solve a problem, they internally have some expectation of how it will behave. When the program they write fails to meet that expectation, they modify the code until it behaves in the way they expect. In way, I consider my philosophy to be an inverted form of Bloom's taxonomy: I have the students begin by diving into code, getting frustrated, and then finding that their current level of knowledge isn't sufficient to complete the task at hand. By waiting until after they struggle with a concrete problem before telling them how to solve it, they contextualize the material from lecture more effectively. Eventually, they go from the top of the taxonomy to the bottom, remembering the personalized solutions that thy managed to build for themselves.

What I've noticed in teaching and tutoring is that the students who are hardest to help are those who aren't willing to experiment and play. The most practical way to encourage this form of learning is to begin each lecture with a programming problem that requires some knowledge the students do not yet have. While the advanced students and those who read the textbook will complete the exercise with little trouble, the students who struggle will have a problem in mind when going over the lecture material, as they will be learning a technique they can immediately apply to the problem frustrating them.

Programming projects have much in common with solving puzzles, and the most important role of the instructor is in developing appropriate challenges designed to enable the learning of the language just-in-time. Just-in-time learning occurs when the techniques necessary to solve a challenge lay just outside their cumulative knowledge, and they must learn something new on their own to complete them. When students reach these solutions on their own, they internalize them, creating a unique learning experience that has far more staying power than instructions from a book or lecture. This becomes the basis of the students' intuition, which is absolutely necessary when students move past the introductory level.

After developing intuition, students are better prepared to have that experience refined into discipline, which I believe is well-suited for structured environments such as lectures, labs, group discussions, and writing assignments. Just-in-time learning is akin to learning a foreign language by immersion - while it teaches students enough of the language to get by, the learning is often uneven and approaches are sub-optimal. In spite of that, after learning how the code works first-hand, they are better equipped to learn the terminology of the language, the most efficient solutions to common problems, and ultimately, the theoretical foundations of computing. If the rules of the language are taught in a formal class prior to this experience, it feels artificial, and may encourage students to learn formulas rather than discover new ways to approach problems.
